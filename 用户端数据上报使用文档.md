# 用户端数据上报使用文档

## 概述

本文档介绍如何在用户端应用中集成数据上报功能，实现API调用日志和使用指标自动回传到admin后端。

## 快速开始

### 1. 引入SDK

```javascript
// 浏览器环境
<script src="client-sdk-example.js"></script>

// Node.js环境
const { DivinationAPI, UsageTracker } = require('./client-sdk-example.js');
```

### 2. 初始化API客户端

```javascript
const api = new DivinationAPI({
  baseURL: 'https://zwam.vryo.de/api',  // 你的API地址
  apiKey: 'zw_live_xxxxxxxxxxxxxxxx',   // 你的API Key
  timeout: 30000
});
```

### 3. 创建使用追踪器

```javascript
const tracker = api.createUsageTracker({
  platform: 'web',           // 平台类型: web, ios, android, wechat
  userId: 'user-123',        // 用户ID（可选）
  batchSize: 10,             // 批量上报大小，默认10
  reportInterval: 60000      // 自动上报间隔，默认1分钟
});
```

## 核心功能

### 1. 自动记录API调用

每次调用AI模型API时，记录详细的调用信息：

```javascript
// 在AI API调用完成后记录
tracker.trackApiCall({
  modelId: 1,                    // AI模型ID
  requestId: 'req-001',          // 请求唯一标识
  tokensUsed: 150,               // 使用的token数量
  cost: 0.003,                   // 调用成本
  responseTimeMs: 1200,          // 响应时间（毫秒）
  status: 'success',             // 状态: success, error, timeout
  errorMessage: null,            // 错误信息（如有）
  metadata: {                    // 额外元数据
    promptType: 'chat',
    userAgent: navigator.userAgent
  }
});
```

### 2. 记录使用指标

记录各种业务指标：

```javascript
// 记录API调用次数
tracker.trackMetric('api_calls', 1);

// 记录token使用量
tracker.trackMetric('total_tokens', 150);

// 记录成本
tracker.trackMetric('total_cost', 0.003);

// 记录用户活跃度
tracker.trackMetric('unique_users', 1);

// 记录卦象使用（如果是占卜应用）
tracker.trackMetric('hexagram_1', 1);  // 卦象ID为1的使用次数
```

### 3. 手动上报数据

```javascript
// 立即上报所有缓存的数据
await tracker.flush();

// 只上报API调用日志
await tracker.flushLogs();

// 只上报使用指标
await tracker.flushMetrics();
```

## 完整使用示例

### 基础聊天应用示例

```javascript
class ChatApp {
  constructor() {
    // 初始化API客户端
    this.api = new DivinationAPI({
      apiKey: 'your-api-key-here'
    });
    
    // 创建使用追踪器
    this.tracker = this.api.createUsageTracker({
      platform: 'web',
      userId: this.getCurrentUserId(),
      batchSize: 5  // 小批量，快速上报
    });
  }

  async sendMessage(message) {
    const startTime = Date.now();
    const requestId = this.generateRequestId();
    
    try {
      // 获取AI模型配置
      const primaryModel = await this.api.getPrimaryAIModel();
      
      // 调用AI API（这里是示例）
      const response = await this.callAIAPI(primaryModel.data, message);
      
      // 记录成功的API调用
      this.tracker.trackApiCall({
        modelId: primaryModel.data.id,
        requestId: requestId,
        tokensUsed: response.usage.total_tokens,
        cost: this.calculateCost(response.usage.total_tokens),
        responseTimeMs: Date.now() - startTime,
        status: 'success'
      });
      
      // 记录使用指标
      this.tracker.trackMetric('api_calls', 1);
      this.tracker.trackMetric('total_tokens', response.usage.total_tokens);
      this.tracker.trackMetric('successful_requests', 1);
      
      return response;
      
    } catch (error) {
      // 记录失败的API调用
      this.tracker.trackApiCall({
        modelId: primaryModel?.data?.id || null,
        requestId: requestId,
        responseTimeMs: Date.now() - startTime,
        status: 'error',
        errorMessage: error.message
      });
      
      // 记录错误指标
      this.tracker.trackMetric('failed_requests', 1);
      
      throw error;
    }
  }
  
  // 应用关闭时清理
  async destroy() {
    await this.tracker.flush();  // 确保所有数据都已上报
    this.tracker.destroy();
  }
}
```

### 占卜应用示例

```javascript
class DivinationApp {
  constructor() {
    this.api = new DivinationAPI({
      apiKey: 'your-api-key-here'
    });
    
    this.tracker = this.api.createUsageTracker({
      platform: 'web',
      userId: this.getCurrentUserId()
    });
  }

  async performDivination(question) {
    const startTime = Date.now();
    
    try {
      // 获取卦象数据
      const hexagrams = await this.api.request('GET', '/public/hexagrams/all');
      
      // 随机选择卦象（简化逻辑）
      const selectedHexagram = this.selectRandomHexagram(hexagrams.data);
      
      // 获取AI解读
      const interpretation = await this.getAIInterpretation(selectedHexagram, question);
      
      // 记录卦象使用
      this.tracker.trackMetric(`hexagram_${selectedHexagram.id}`, 1);
      
      // 记录占卜次数
      this.tracker.trackMetric('divination_count', 1);
      
      // 记录用户活跃度
      this.tracker.trackMetric('unique_users', 1);
      
      return {
        hexagram: selectedHexagram,
        interpretation: interpretation
      };
      
    } catch (error) {
      this.tracker.trackMetric('divination_errors', 1);
      throw error;
    }
  }
}
```

## 高级配置

### 自定义上报策略

```javascript
// 高频应用 - 快速上报
const highFreqTracker = api.createUsageTracker({
  platform: 'web',
  batchSize: 5,           // 小批量
  reportInterval: 30000   // 30秒上报一次
});

// 低频应用 - 节省资源
const lowFreqTracker = api.createUsageTracker({
  platform: 'mobile',
  batchSize: 50,          // 大批量
  reportInterval: 300000  // 5分钟上报一次
});
```

### 错误处理和重试

```javascript
class RobustTracker {
  constructor(api) {
    this.tracker = api.createUsageTracker({
      platform: 'web'
    });
    
    // 监听上报失败事件
    this.setupErrorHandling();
  }
  
  setupErrorHandling() {
    // 重写flush方法，添加重试逻辑
    const originalFlush = this.tracker.flush.bind(this.tracker);
    
    this.tracker.flush = async (retries = 3) => {
      for (let i = 0; i < retries; i++) {
        try {
          await originalFlush();
          return;
        } catch (error) {
          console.warn(`数据上报失败，重试 ${i + 1}/${retries}:`, error.message);
          if (i === retries - 1) throw error;
          await this.delay(1000 * (i + 1)); // 递增延迟
        }
      }
    };
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## 数据隐私和安全

### 1. 敏感数据处理

```javascript
// ❌ 不要记录敏感信息
tracker.trackApiCall({
  // 不要包含用户输入内容、密码等敏感信息
  userInput: message,  // 错误示例
  
  // ✅ 只记录技术指标
  tokensUsed: 150,
  responseTimeMs: 1200,
  status: 'success'
});
```

### 2. 用户同意机制

```javascript
class PrivacyAwareTracker {
  constructor(api) {
    this.api = api;
    this.tracker = null;
    this.userConsent = false;
  }
  
  // 用户同意后才开始追踪
  enableTracking(userId) {
    if (this.userConsent) {
      this.tracker = this.api.createUsageTracker({
        platform: 'web',
        userId: userId
      });
    }
  }
  
  // 用户可以随时停止追踪
  disableTracking() {
    if (this.tracker) {
      this.tracker.destroy();
      this.tracker = null;
    }
  }
}
```

## 性能优化

### 1. 批量处理

```javascript
// 使用较大的批量大小减少网络请求
const tracker = api.createUsageTracker({
  batchSize: 20,        // 积累20条记录再上报
  reportInterval: 120000 // 2分钟强制上报一次
});
```

### 2. 离线支持

```javascript
class OfflineTracker {
  constructor(api) {
    this.api = api;
    this.tracker = api.createUsageTracker();
    this.offlineQueue = [];
    
    // 监听网络状态
    window.addEventListener('online', this.handleOnline.bind(this));
    window.addEventListener('offline', this.handleOffline.bind(this));
  }
  
  handleOffline() {
    // 离线时暂停自动上报
    this.tracker.stopAutoReport();
  }
  
  async handleOnline() {
    // 恢复网络时上报离线期间的数据
    if (this.offlineQueue.length > 0) {
      try {
        await this.api.batchReport(this.offlineQueue, []);
        this.offlineQueue = [];
      } catch (error) {
        console.warn('离线数据上报失败:', error.message);
      }
    }
    
    // 恢复自动上报
    this.tracker.startAutoReport();
  }
}
```

## 调试和监控

### 1. 开启调试日志

```javascript
// 在开发环境中开启详细日志
const tracker = api.createUsageTracker({
  platform: 'web',
  debug: true  // 开启调试模式（需要在SDK中实现）
});

// 手动检查上报状态
console.log('待上报日志数量:', tracker.logs.length);
console.log('待上报指标数量:', tracker.metrics.size);
```

### 2. 健康检查

```javascript
// 定期检查API连接状态
setInterval(async () => {
  const isHealthy = await api.healthCheck();
  if (!isHealthy) {
    console.warn('API连接异常，数据上报可能受影响');
  }
}, 300000); // 5分钟检查一次
```

## 常见问题

### Q: 数据上报失败怎么办？
A: SDK会自动重试，失败的数据会重新加入队列。可以通过监听错误日志来了解失败原因。

### Q: 如何减少网络流量？
A: 增加`batchSize`和`reportInterval`参数，减少上报频率。

### Q: 是否支持离线使用？
A: 需要自行实现离线缓存机制，网络恢复后批量上报。

### Q: 如何保护用户隐私？
A: 只上报技术指标，不包含用户输入内容或个人信息。

## API参考

详细的API接口文档请参考：
- `POST /public/usage/log` - 记录API调用日志
- `POST /public/usage/metrics` - 上报使用指标  
- `POST /public/usage/batch` - 批量上报数据

---

**注意**: 请确保你的API Key具有`usage:write`权限才能使用数据上报功能。
